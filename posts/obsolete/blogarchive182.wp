NOIP2007树网的核中需要计算图中到子图的最短距离最长的结点 方法是将子图中的边给删去 然后分别从子图的结点去寻找最短距离最长点
由于此题图是树状结构，故最短距离就是两结点距离 关于子图和其他节点的关系： **定理：**在讨论子图整体和其他节点关系时可以忽略其内部节点间的边关系

**理解方法1:**可以这样考虑，假设已经访问到了子图中的一个节点，那么已经算是访问到了这个子图了，完全没有必要再在子图内部进行转移！这另我不由得想到了物理受力分析时的“整体法”。大意是如果把几个物体看作一个整体，那么就可以忽略他们之间的内部的力的情况。和图论的是神似阿！

岂止是神似！图论是一个强大模型。。其实物理受力模型完全就可以进行图论建模来解决，用节点表示物体(质点)，用节点间两个有向边表示施力和受力关系（两个是因为力的
相互性），那么整体法不就是将一些节点弄成子图来讨论吗？！

**理解方法2:**可以这样考虑，由于讨论的是子图整体和其他节点的关系，完全可以将子图看成一个点，这就是“缩点”。既然全部缩成一个点，那么原子图内节点间的关系就没有意义了，可以忽略。另外，虽然说缩成一个点，但是在图结构上是几个点，那几个点就是子图的“大点”的分身。。当研究这个“大点”也就是子图整体和外部结点的关系时，相当于分别研究各个分身和外部的关系。

OK,贴出NOIP2007树网的核的代码：

    
    
    
    #include 
    
    #include 
    
    #define INF 999999
    
    
    
    using namespace std;
    
    
    
    int tmp[1000];
    
    int map[301][301];
    
    bool used[301];
    
    bool hash[301];
    
    
    
    int d[300],l=0,maxx=0;
    
    int n,s,ECC=INF;
    
    
    
    void findl(int k,int inc) {
    
    
    
    	for (int i=1; imaxx)
    
    	{
    
    		maxx=inc;
    
    		l=k;
    
    	}
    
    }
    
    
    
    void findd(int k,int inc,int p) {
    
    
    
    	bool flag=1;
    
    	for (int i=1; imaxx)
    
    	{
    
    		maxx=inc;
    
    		for (int i=1; imaxx) maxx=inc;
    
    }
    
    
    
    
    
    void trycore() {
    
    
    
    	for (int i=1; immax) mmax=maxx;
    
    		}
    
    		if (mmax

