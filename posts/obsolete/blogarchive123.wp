话说Tim牛给我了一道看似简单的题。。从此开始了囧程。。 题目要求求解一个三次方程，ax^3+bx^2+cx+d=0
并且a,b,c,d是c++double(Pascal Extended)范围（**此处伏有一个囧**）。。
对于根。。如果两不同根差至少0.01（**此处伏有一个囧**） 根的范围在 [-1000000,+1000000]区间内。
========================囧的分割线=========================
思路很明显是二分（**此处伏有一个囧**），但是我很快就意识到了这个二分~不寻常~ 由于三次方程。没学过==|所以Tim给出了图象。这里我就懒得画了。。
关键在于图象有两个拐点x1,x2，在从-1000000到x1处函数恒增，从x1~x2处恒减 而从x2~+1000000处又是恒增，因此要分别二分。
利用三次函数的导数（令其为0）来求出x1,x2，注意导数也是个二次函数，有可能Δ=0或Δ<0 （**此处有囧**） **但是三次函数至少有一个实根！！！**
好了，就开始二分。。囧囧们就陆续出现了。。 =========================orz orz
orz================================== 第一囧：未挂文件。。。可能是ELOJ做多了，人懒了。
第二囧：大囧也。直到倒数第二次提交前才发现。因为系数可能很大所以即使二分到了根。但因为精度问题导致计算y值“过大” 这里就有一个问题：什么叫大？Tim牛的一
个提示使我猛然醒悟：“因为系数最大可以到10^18，几十万和它相比是渣渣。。。”（顺口溜？）是啊！误差是相对的，相对于数据规模，于是我就设立一个关于系数的根
最大误差。（以前一直用0.01来判断是否是根，所以一改就过了8个点）
第三囧：**三次函数至少有一个实根**也就是即使导数函数的Δ=0但是三次函数仍有解。有没有解与导数的Δ无关。 第四囧：若根为-0.0013
那保留两位小数后岂不是成了-0.00（囧==|），所以得处理掉。。 第五囧：二分有可能分出两个重复根。。 另囧：题上已经提示所以就没有遭。。

> 请特别注意下精度问题，直接判两根的距离大于等于0.01可能会因为两根离得比较近而所得的结果的差小于0.01，比如：答案为 0.01 和0.02，而程序得
到的结果为0.012000和0.019888，此时两根差为0.007888<0.01，但应输出0.01和0.02，所以提示请把两根最小差调整到比0.01小点
的数，具体请自行测试分析。（摘自NOIP集训题by Tim）

OK就这样。。。 =================不囧不囧不囧不囧不囧不囧不囧不囧========================== 知识点：
**1.浮点数运算存在误差 (比如不能直接用x==0来判断(double x;))**
**2.误差影响是相对的。。而非绝对的大小。。所以一个偏差是否能容忍取决于它与数据规模的比值**
**3.三次函数求解相关知识：导数求解以及三次函数的性质（必有实根）**
=================震慑震慑震慑震慑震慑震慑震慑震慑震慑========================
今天我问我爸怎么处理他们建筑结构运算中的误差。。（他也是用c++编过简单的计算） 他说“我们要求精度不高”。。我巨汗。。
然后他又说“因为我们一般用MM(别想歪。。毫米啦)作单位”。精辟！！！
这就是另一种思路！！减少误差还可以将浮点数扩大，将小数部分尽可能放到整数区去～我怎么把这个忘了？。。 囧rz.... 震慑阿～ **贴代码时间！**

    
    
    
    #include 
    
    #include 
    
    #include 
    
    
    
    using namespace std;
    
    
    
    double a,b,c,d;
    
    const double MIN=-1000000.00000F;
    
    const double MAX=1000000.00000F;
    
    const double MM=0.005700F;//见到MM不要流口水。。这个是指根最小间距，在0.01上进行了调整
    
    double isroot,res[4];
    
    int  have=0;
    
    
    
    void solve(double l,double r,int sect) {
    
    
    
    	double mid=(l+r)/2;
    
    	double fmid=a*mid*mid*mid+b*mid*mid+c*mid+d;
    
    	if (abs(r-l)0) solve(l,mid,sect);
    
    			else solve(mid,r,sect);
    
    	}
    
    	else
    
    	{
    
    		if (fmid>0) solve(mid,r,sect);
    
    			else solve(l,mid,sect);
    
    	}
    
    }
    
    
    
    
    
    int main() {
    
    	double x1,x2,delta,sq_del,res1,res2,res3;
    
    	freopen("equation.in","r",stdin);
    
    	freopen("equation.out","w",stdout);
    
    	scanf("%lf%lf%lf%lf",&a,&b,&c,&d);
    
    	isroot=abs(a*0.000001+b*0.0001+c*0.01+d);//最大允许偏差
    
    	delta=4*b*b-12*a*c;
    
    	if (a!=0)//如果是三次方程
    
    	{
    
     		if (delta>0) //如果导数delta为正（两个拐点）则要分三段进行二分
    
    		{
    
    			sq_del=sqrt(delta);
    
    			x1=(-2*b-sq_del)/(6*a);
    
    			x2=(-2*b+sq_del)/(6*a); //x1MM && have>1) printf("%.2lf\n",res[2]);//分区间二分时有可能重复根
    
    		if (abs(res[3]-res[2])>MM && have>2) printf("%.2lf\n",res[3]);//同上
    
    	}
    
    	else//二次方程直接用公式
    
    	{
    
    		delta=c*c-4*b*d;
    
    		if (delta>=0)
    
    		{
    
    			have=1;
    
    			sq_del=sqrt(delta);
    
    			x1=(-c-sq_del)/(2*b);
    
    			x2=(-c+sq_del)/(2*b);
    
    			printf("%.2lf\n",x1);
    
    			if (x2-x1>=MM) printf("%.2lf\n",x2);
    
    		}
    
    		else printf("%s","No real solution.");//二次方程无实根。。
    
    	}
    
    
    
    }
    
    

